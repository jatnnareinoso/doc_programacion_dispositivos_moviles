# doc_programacion_dispositivos_moviles

Este repositorio posee información acerca de los frameworks más utilizados para el desarrollo de aplicaciones móviles. 

# Flutter
Flutter es un framework que permite el desarrollo de un proyecto de programación. Es gratuito y de código abierto, y fue creado por Google en mayo de 2017. Permite crear una aplicación móvil nativa con una sola base de código, por lo que se puede usar un lenguaje de programación y una base de código para crear dos aplicaciones diferentes (para iOS y Android) 

- Lenguaje de programación base: El SDK de Flutter se basa en el lenguaje de programación Dart, que también fue creado por Google con el objetivo de convertirse en un sucesor de JavaScript. Igual que este, Dart se ejecuta directamente en el navegador. 
En un servidor, los programas construidos en Dart se pueden ejecutar de forma directa; en un navegador, por su parte, se ejecutan en JavaScript mediante el transcompilador Dart2js.
- Enlance a la página oficial de la tecnología: (https://flutter.dev/)
- Repositorios de ejemplos: [https://github.com/flutter/samples]
- Creador: Flutter es un SDK desarrollado por Google para crear aplicaciones móviles tanto para Android como para iOS (Apple).
- Empresa encargada de mantenimiento: Google
- Fecha de creación: 4 de Diciembre de 2018


# Xamarin

Xamarin es un framework de desarrollo de aplicaciones móviles multiplataforma. Permite a los desarrolladores crear aplicaciones para iOS, Android y Windows utilizando un lenguaje de programación compartido: C#. Con Xamarin, puedes escribir una única base de código en C# y luego compilarlo para diferentes plataformas móviles, lo que brinda eficiencia y facilita el desarrollo y mantenimiento de aplicaciones multiplataforma.
- Lenguaje de programación base: Lenguaje C#. Xamarin utiliza un único lenguaje, C#, para crear aplicaciones de todas las plataformas móviles. Xamarin está compilado de forma nativa, lo que lo convierte en una opción para crear aplicaciones de alto rendimiento con aspecto nativo.
- Enlace a la página oficial de la tecnología: [https://dotnet.microsoft.com/apps/xamarin]
- Repositorios de ejemplos: [https://github.com/
- Creador: Microsoft
- Empresa encargada de mantenimiento: Microsoft
- Fecha de creación: Mayo de 2011

# React Native 
React Native es un framework de código abierto creado por Facebook que permite a los desarrolladores crear aplicaciones móviles para iOS y Android utilizando JavaScript y la biblioteca de React, que se utiliza para crear interfaces de usuario. React Native funciona al permitir a los desarrolladores escribir una sola base de código en JavaScript y luego compilarlo para ambas plataformas, lo que reduce el tiempo y los recursos necesarios para desarrollar una aplicación móvil para ambas plataformas.

- Lenguaje de programación base: React Natives utiliza JavaScript como lenguaje de programación subyacente, y su objetivo es ayudar a los desarrolladores a crear aplicaciones móviles nativas para dispositivos Android e IOS con una sola base de código.
- Enlace a la página oficial de la tecnología: [https://reactnative.dev/]
- Repositorios de ejemplos: [https://github.com/facebook/react-native]
- Creador: Jordan Walke, Ingeniero de Software en Facebook.
- Empresa encargada de mantenimiento: Facebook.
- Fecha de creación: Marzo de 2013

 # Ionic
 
 Ionic Framework es un SDK de frontend de código abierto para desarrollar aplicaciones híbridas basado en tecnologías web (HTML, CSS y JS). Es decir, un framework que nos permite desarrollar aplicaciones para iOS nativo, Android y la web, desde una única base de código. Su compatibilidad y, gracias a la implementación de Cordova e Ionic Native, hacen posible trabajar con componentes híbridos. Se integra con los principales frameworks de frontend, como Angular, React y Vue, aunque también se puede usar Vanilla JavaScript. Este framework fue creado en 2013 por Drifty Co. y hasta la llegada de React Native ha sido una de las tecnologías líderes para el desarrollo de aplicaciones móviles híbridas.
 
- Lenguaje de programación base: Se caracteriza por utilizar HTML5 como lenguaje de maquetación para las vistas de las aplicaciones y AngularJS para la programación de controladores y funcionalidades.
- Enlace a la página oficial de la tecnología: [https://ionic.io/]
- Repositorios de ejemplos: [https://github.com/ionic-team/ionic-samples]
- Creador: Drifty Co.
- Empresa encargada de mantenimiento: Ionic Team.
- Fecha de creación: Noviembre 2013

# Swiftic
Swiftic es una plataforma de aplicaciones móviles que facilita la creación de aplicaciones personalizadas para cualquier empresa. Simplifica el desarrollo de aplicaciones permitiendo a los programadores integrar material actual de Internet en lugar de hacerlo desde cero. Es uno de los marcos de desarrollo de aplicaciones móviles más flexibles, ya que ofrece una experiencia de usuario bastante fluida, banca especializada y estrategias sencillas.

- Lenguaje de programación base:  A diferencia de otros frameworks o plataformas de desarrollo móvil, Swiftic no se basa en un lenguaje de programación específico como base.
En lugar de requerir conocimientos de programación en un lenguaje en particular, Swiftic utiliza una interfaz visual y un editor intuitivo que permite a los usuarios diseñar y personalizar sus aplicaciones móviles sin necesidad de escribir código.
- Enlace a la página oficial de la tecnología: [https://www.swiftic.com/]
- Repositorios de ejemplos: [https://github.com/ionic-team/ionic-samples]
- Creador: Apple.
- Empresa encargada de mantenimiento: Swiftic Ltd.
- Fecha de creación: Se creó en 2014 y se lanzó al público como un proyecto de código abierto en 2015.

Comparación entre las diversas tecnologías.

| Framework   | Lenguaje Base | Desarrollado por      |   Ventajas            |  Desventajas    |   
|-------------|--------------------------|---------------------|---------------------|---------------------|
| Flutter | Dart | Google  |Alta velocidad de desarrollo y rendimiento. Interfaz de usuario atractiva y personalizable. Soporte de hot reload para una iteración rápida de desarrollo. | Mayor curva de aprendizaje de Dart. Tamaño de archivo de la aplicación más grande. Menor cantidad de bibliotecas y componentes disponibles.
| Xamarin | C#  |Microsoft | Código compartido entre múltiples plataformas. Acceso completo a las APIs nativas. Integración estrecha con Microsoft y Visual Studio. | Requiere conocimientos en C# y .NET. Mayor tiempo de compilación. Requiere implementaciones específicas por plataforma.
| React Native | JavaScript | Facebook | Utiliza JavaScript y bibliotecas populares. Amplia comunidad y disponibilidad de componentess. Actualizaciones en tiempo real.  | Posible pérdida de rendimiento. Dependencia de bibliotecas y módulos de terceros. Menor acceso a APIs |
| Ionic | HTML y JavaScript (Angular) | Iconic Team | Desarrollo basado en tecnologías web estándar. Amplia disponibilidad de componentes. Soporte multiplataforma. | Dependencia de WebView. Requiere ajustes adicionales para una apariencia nativa. Menor rendimiento. |
| Swiftic | N/A | Apple | No requiere conocimientos de programación avanzados. Interfaz visual y editor  intuitivo para el desarrollo de aplicaciones. Facilidad de uso y accesibilidad. | Limitaciones en funcionalidades. No permite un control completo del código. No se basa en un lenguaje de programación específico.  |  

# Patrones de Diseño: 

# Patrones Creacionales: 
Estos patrones proporcionan mecanismos de creación de objetos que incrementan la flexibilidad y la reutilización del código existente. 
  
-----

#### Patrón Factory Method:
Es un patrón de diseño creacional que proporciona una interfaz para crear objetos, pero permite a las subclases decidir que clase concreta instanciar. Encapsula la creación de objetos en una clase separada, conocida como la clase creadora, que contiene un método de fábrica. Este método se utiliza para crear objetos de una o más clases concretas que implementan una interfaz común o son subclases de una misma clase abstracta. 

### Patrón Abstract Factory:
Es otro patrón de diseño creacional que proporciona una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas. Es similar al patrón Factory Method, pero se enfoca en la creación de familias de objetos en lugar de objetos individuales. Sigue el principio de diseño conocido como inversión de dependencias, ya que las clases de alto nivel dependen de abstracciones en lugar de depender de clases concretas. 

### Patrón Builder
Es un patrón de diseño creacional que se utiliza para construir objetos complejos paso a paso. Proporciona una forma flexible de crear objetos, permitiendo la creación de diferentes variantes o configuraciones de un objeto utilizando el mismo proceso de construcción. Se utiliza cuando la creación de un objeto requiere un proceso complicado o requiere múltiples pasos, y se desea separar la construcción del objeto de su representación final. 

### Patrón Prototype
Se utiliza para crear objetos mediante la clonación de un prototipo existente en lugar de crearlos desde cero. El prototipo es una instancia preexistente que se utiliza como plantilla para la creación de nuevos objetos, lo que permite la creación de objetos complejos sin acoplar el código cliente a las clases concretas. Se basa en el uso de la clonación, que puede ser superficial o profunda.

### Patrón Singleton
Es un patrón de diseño creacional que se utiliza para garantizar que una clase solo tenga una única instancia y proporcionar un punto de acceso global a esa instancia. Esto significa que no se pueden crear múltiples instancias de la clase Singleton y solo se puede acceder a la instancia existente a través de un método estático. 

---
# Patrones Estructurales:
Estos patrones explican cómo ensamblar objetos y clases en estructuras más grandes, mientras se mantiene la flexibilidad y eficiencia de la estructura.

### Patrón Adapter:
Es un patrón de diseño estructural que permite que dos interfaces incompatibles puedan trabajar juntas. El adaptador funciona como un puente entre dos clases o componentes que tienen interfaces diferentes, permitiendo que interactúen sin necesidad de modificar su código fuente. 

### Patrón Bridge:
Es un patrón de diseño estructural que separa la abstracción de su implementación, permitiendo que ambas varíen de forma independiente. Este patrón se utiliza cuando se desea desacoplar una abstracción de su implementación, de modo que ambas puedan evolucionar de forma independiente. Facilita la modificación y extensión de ambas de forma independiente. 

### Patrón Composite:
Es el patrón que permite tratar a los objetos individuales y a las composiciones de objetos de manera uniforme. El patrón Composite se utiliza cuando se desea representar una jerarquía de objetos en forma de árbol, y se quiere tratar tanto a los objetos individuales como a las agrupaciones de objetos de manera transparente. Facilita la creación de estructuras jerárquicas y permite al cliente interactuar con la estructura sin tener que distinguir entre objetos individuales y agrupaciones. 

### Patrón Decorator: 
Es un patrón de diseño estructural que permite agregar comportamiento adicional a un objeto existente dinámicamente, sin modificar su estructura básica. El patrón Decorator se utiliza cuando se desea extender o modificar el comportamiento de un objeto en tiempo de ejecución, de manera flexible y sin tener que crear subclases. Es útil cuando se tienen múltiples opciones de decoración y se desea combinarlas de forma dinámica. 

### Patrón Facade:
Es un patrón de diseño estructural que proporciona una interfaz simplificada y unificada para un conjunto de interfaces más complejas y subsistemas. El patrón Facade se utiliza cuando se desea proporcionar una interfaz de nivel superior que oculta la complejidad interna de un sistema y facilita su uso. El patrón Facade simplifica el uso de un sistema al proporcionar una interfaz única y simplificada para el cliente. 

### Patrón Flyweight:
Es un patrón de diseño estructural que se utiliza para minimizar el uso de memoria o recursos al compartir eficientemente objetos pequeños que son frecuentemente utilizados. El patrón Flyweight se centra en dividir los objetos en dos tipos: los intrínsecos (compartidos) y los extrínsecos (no compartidos). El patrón Flyweight permite reducir la cantidad de objetos que se crean y se almacenan en memoria, compartiendo objetos intrínsecos entre diferentes contextos.

### Patrón Proxy:
Este patrón actúa como intermediario o sustituto de un objeto para controlar el acceso a este. El patrón Proxy se utiliza para proporcionar una interfaz similar al objeto real y controlar las operaciones adicionales que se realizan antes o después de acceder al objeto real. El patrón Proxy se utiliza en situaciones donde se desea controlar el acceso a un objeto, como, por ejemplo, para proporcionar seguridad, realizar verificaciones adicionales, realizar cacheo de resultados o limitar el acceso al objeto real. 

-- -- 
# Patrones de Comportamiento:
Estos patrones tratan con algoritmos y la asignación de responsabilidades entre objetos.

### Patrón Chain of Responsibility:
Este permite construir una cadena de objetos receptores, donde cada objeto en la cadena tiene la posibilidad de manejar una solicitud. Si un objeto no puede manejar la solicitud, la pasa al siguiente objeto en la cadena. Este patrón evita acoplar el remitente de una solicitud con su receptor, permitiendo que múltiples objetos tengan la oportunidad de manejar la solicitud de forma independiente.

### Patrón Command:
Este patrón encapsula una solicitud como un objeto, permitiendo parametrizar clientes con diferentes solicitudes, encolar o registrar solicitudes, y soportar operaciones deshacer y rehacer. El patrón Command permite desacoplar el objeto que realiza una acción (el cliente) del objeto que sabe cómo llevar a cabo la acción (el receptor).

### Patrón Iterator:
Este patrón proporciona una forma de acceder secuencialmente a los elementos de una colección sin exponer su representación interna. El patrón Iterator permite recorrer una colección de objetos de manera uniforme, independientemente de la estructura subyacente de la colección.

### Patrón Mediator:
Este patrón promueve la comunicación indirecta y la interacción entre objetos al centralizarla a través de un objeto mediador. El mediador actúa como un intermediario entre los objetos, eliminando las dependencias directas entre ellos y promoviendo un acoplamiento más débil.

### Patrón Memento:
Permite capturar y almacenar el estado interno de un objeto sin violar su encapsulamiento, para poder restaurar ese estado posteriormente. El patrón Memento permite guardar y recuperar instantáneas del estado de un objeto en diferentes puntos de tiempo, sin que el objeto expuesto conozca los detalles de implementación.

### Patrón Observer: 
Establece una relación de dependencia uno a muchos entre objetos, de manera que cuando un objeto cambia su estado, todos los objetos dependientes son notificados y actualizados automáticamente. El patrón Observer permite la comunicación y la propagación de cambios entre objetos de manera desacoplada y flexible.

### Patrón State:
Permite que un objeto pueda cambiar su comportamiento en función de su estado interno. El patrón State se basa en la encapsulación de los diferentes estados posibles de un objeto en clases separadas, lo que permite que el objeto pueda cambiar su comportamiento simplemente cambiando de estado.

### Patrón Strategy:
Permite definir una familia de algoritmos, encapsular cada uno de ellos y hacerlos intercambiables. El patrón Strategy permite que el algoritmo utilizado pueda variar independientemente de los clientes que lo utilizan. El patrón Strategy se utiliza cuando se necesita utilizar diferentes algoritmos de manera intercambiable en un objeto y cuando se desea evitar la duplicación de código para diferentes variantes de un algoritmo.

### Patrón Template Method:
Define la estructura básica de un algoritmo en una clase base, delegando la implementación de ciertos pasos a las subclases. El patrón Template Method permite definir un esqueleto de algoritmo en la clase base y permite que las subclases implementen o sobrescriban ciertos pasos según sea necesario.

### Patrón Visitor:
Permite separar algoritmos de la estructura de objetos en la que operan. El patrón Visitor permite agregar nuevos comportamientos a una estructura de objetos existente sin modificar dicha estructura. También es útil cuando se tienen operaciones complejas que involucran múltiples tipos de objetos y se desea mantener el código de operación separado de la estructura de objetos.



